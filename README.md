# @selfage/message

## Install

`npm install @selfage/message`

## Overview

Written in TypeScript and compiled to ES6. Provides message descriptor definitions and utils to assist runtime processing. A message descriptor is typically generated by using `@selfage/cli`.

The term "message" stands for data class, inspired from Google's protobuf. I.e., in JavaScript/TypeScript case, an object without any functions defined on it,
which is what can be communicated between different threads, processes, or distributed servers.

A descriptor is an object holding information, even at runtime, about how a message is defined, just like declaring a TypeScript `interface`, except that an interface is erased at runtime.

## Generate MessageDescriptor

Technically, you can generate a `MessageDescriptor` manually, or by using a generator of yours.

By using `@selfage/cli`, it requires a JSON file as input, e.g. `basic.json`, to describe the message as the following.

```JSON
[{
  "message": {
    "name": "BasicData",
    "fields": [{
      "name": "numberField",
      "type": "number"
    }, {
      "name": "stringArrayField",
      "type": "string",
      "isArray": true
    }]
  }
}]
```

It's just like a TypeScript interface but a little bit verbose when written in JSON. The schema of the JSON file is an array of [Definition](https://github.com/selfage/cli/blob/5db1a453bccf6e12f6bc7f96c708833c07188d12/generate/definition.ts#L57).

After running `$ selfage gen basic`, you will get a `basic.ts` file, which looks like the follwing.

```TypeScript
import { MessageDescriptor, PrimitiveType } from '@selfage/message/descriptor';

export interface BasicData {
  numberField?: number,
  stringArrayField?: Array<string>
}

export let BASIC_DATA: MessageDescriptor<BasicData> = {
  name: 'BasicData',
  factoryFn: () => {
    return new Object();
  },
  fields: [
    {
      name: 'numberField',
      primitiveType: PrimitiveType.NUMBER,
    },
    {
      name: 'stringArrayField',
      primitiveType: PrimitiveType.STRING,
      arrayFactoryFn: () => {
        return new Array<any>();
      },
    },
  ]
};
```

It's recommended to commit `basic.ts` as a source file such that any code change on `@selfage/cli` will not break your program.

## Parse messages at runtime

With a `MessageDescriptor`, you can then parse an `any` object into a typed object by validating each field type, e.g., from a JSON-parsed object.

```TypeScript
import { parseMessage } from '@selfage/message/parser';
import { BASIC_DATA, BasicData } from './basic'; // As generated from the example above.

let raw = JSON.parse(`{ "numberField": 111, "otherField": "random", "stringArrayField": ["str1", "str2"] }`);
let basicData = parseMessage(raw, BASIC_DATA); // Of type `BasicData`.
basicData.numberField; // 111
basicData.stringArrayField; // ["str1", "str2"]
basicData.otherField; // undefined
```

You can also supply an in-place output.

```TypeScript
// ...
let output: BasicData = {};
parseMessage(raw, BASIC_DATA, output);
```

## Generate EnumDescriptor

TypeScript preserves enum information at runtime. Therefore, `EnumDescriptor` only exists for `MessageDescriptor` to reference.

An example JSON file, `color.json`, is as the following.

```JSON
[{
  "enum": {
    "name": "Color",
    "values": [{
      "name": "RED",
      "value": 12
    }, {
      "name": "BLUE",
      "value": 1
    }]
  }
}]
```

With `@selfage/cli`, you will get `color.ts` as the following.

```TypeScript
import { EnumDescriptor } from '@selfage/message/descriptor';

export enum Color {
  RED = 12,
  BLUE = 1,
}

export let COLOR: EnumDescriptor<Color> = {
  name: 'Color',
  values: [
    {
      name: 'RED',
      value: 12,
    },
    {
      name: 'BLUE',
      value: 1,
    },
  ]
}
```

## Parse enums at runtime

Also because TypeScript perserves enum information at runtime. The following parser is mainly used when parsing messages.

```TypeScript
import { parseEnum } from '@selfage/message/parser';
import { COLOR, Color } from './color'; // As generated from the example above.

let raw = 1 as any;
let blue = parseEnum(raw, COLOR); // of type Color.
let raw2 = 'RED' as any;
let red = parseEnum(raw2, COLOR); // of type Color.
```

## Generate observable message

`@selfage/cli` can also generate observable messages which expose listeners on changes happen on each property/member/field, by specifying `isObservable: true`. Taken the example `basic.json` above and modified as the following.

```JSON
[{
  "message": {
    "name": "BasicData",
    "fields": [{
      "name": "numberField",
      "type": "number"
    }, {
      "name": "stringArrayField",
      "type": "string",
      "isArray": true
    }],
    "isObservable": true
  }
}]
```

After running `$ selfage gen basic`, you will get a `basic.ts` file, which looks like the follwing.

```TypeScript
export class BasicData {
  public onNumberFieldChange: (newValue: number, oldValue: number) => void;
  private numberField_?: number;
  get numberField(): number {
    return this.numberField_;
  }
  set numberField(value: number) {
    let oldValue = this.numberField_;
    if (value === oldValue) {
      return;
    }
    this.numberField_ = value;
    if (this.onNumberFieldChange) {
      this.onNumberFieldChange(this.numberField_, oldValue);
    }
  }

  public onStringArrayFieldChange: (newValue: ObservableArray<string>, oldValue: ObservableArray<string>) => void;
  private stringArrayField_?: ObservableArray<string>;
  get stringArrayField(): ObservableArray<string> {
    return this.stringArrayField_;
  }
  set stringArrayField(value: ObservableArray<string>) {
    let oldValue = this.stringArrayField_;
    if (value === oldValue) {
      return;
    }
    this.stringArrayField_ = value;
    if (this.onStringArrayFieldChange) {
      this.onStringArrayFieldChange(this.stringArrayField_, oldValue);
    }
  }
  
  public toJSON(): Object {
    return {
      numberField: this.numberField;
      stringArrayField: this.stringArrayField;
    };
  }
}

export let BASIC_DATA: MessageDescriptor<BasicData> = {
  name: 'BasicData',
  factoryFn: () => {
    return new BasicData();
  },
  fields: [
    {
      name: 'numberField',
      primitiveType: PrimitiveType.NUMBER,
    },
    {
      name: 'stringArrayField',
      primitiveType: PrimitiveType.STRING,
      observableArrayFactoryFn: () => {
        return new ObservableArray<any>();
      },
    },
  ]
};
```

It's recommended to commit `basic.ts` as a source file such that any code change on `@selfage/cli` will not break your program. Note that you will need to install `@selfage/observable_array` if your observable message contains arrays.

## Listen on observable message

Changes are detected through TypeScript setter. Listeners can be added as the following.

```TypeScript
import { BasicData } from './basic';
import { ObservableArray } from '@selfage/observable_array'; // Install @selfage/observable_array

let basicData = new BasicData();
basicData.onNumberFieldChange = (newValue, oldValue) => {
  console.log(`newValue: ${newValue}; oldValue: ${oldValue};`);
}
basicData.numberField = 10;
// Print: newValue: 10; oldValue: undefined;
basicData.numberField = 100;
// Print: newValue: 100; oldValue: 10;
delete basicData.numberField;
// Actually does nothing. basicData.numberField is still 100.
basicData.numberField = undefined;
// Print: newValue: undefined; oldValue: 100;

basicData.onStringArrayFieldChange = (newValue, oldValue) => {
  console.log(`newValue: ${JSON.stringify(newValue)}; oldValue: ${JSON.stringify(oldValue)};`);
}
basicData.stringArrayField = ObservableArray.of('str1', 'str2');
// Print: newValue: ['str1','str2']; oldValue: undefined;
basicData.stringArrayField = ObservableArray.of('str1', 'str2');
// Print: newValue: ['str1','str2']; oldValue: ['str1','str2'];
// This is because the new and old ObservableArray's are not the instance. I.e., they are not equal by `===`.
basicData.stringArrayField.push('str3');
// Nothing to print as changes are not bubbled up.
```

In order to observe arrays, please add a listener on `basicData.stringArrayField` directly. Refer to package `@selfage/observable_array` for explanation.

Changes on `BasicData` are not bubbled up either, even if you nest `BasicData` inside another observable message. Always add listeners on nested observable messages directly.

## Parse observable messages at runtime

Not only we have generated an observable message but also a `MessageDescriptor` in the example above. With that, you can parse a JSON-parsed object into an observable message the same way as a non-observable message.

```TypeScript
import { parseMessage } from '@selfage/message/parser';
import { BASIC_DATA, BasicData } from './basic'; // As generated from the example above.

let raw = JSON.parse(`{ "numberField": 111, "otherField": "random", "stringArrayField": ["str1", "str2"] }`);
let output = new BasicData();
// Providing an output argument might be preferred because you can add listeners here before parsing input.
parseMessage(raw, BASIC_DATA, output);
```

## Test matcher

Provides an implementation of test matcher taking a `MessageDescriptor` to be used with `@selfage/test_base`.

```TypeScript
import { BasicData, BASIC_DATA } from './basic'; // As generated from the example above.
import { eqMessage } from '@selfage/message/test_matcher';
import { assertThat } from '@selfage/test_base/matcher'; // Install @selfage/test_base

let basicData: BasicData = { numberField: 111 };
assertThat(basicData, eqMessage({ numberField: 111 }, BASIC_DATA), `basicData`);
```
